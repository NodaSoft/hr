# Описание результата работы

Код был полность переработан, так как ограничений по времени, количеству строк изменяемого кода или импорта пакетов не было.
*Понимаю, что получилась каша из топора, просто фраза \"as best as you can\" звучала как вызов :)*

Результат работы решил описать на русском, потому что такое ~~переведенное~~ написанное мною полотно вам будет очень больно читать.

## Импорт пакетов
Для реализации всех задумок добавил пакеты:
- `uber-go/zap` - для более удобного логирования событий в системе,
- `google/uuid` - для использования в качестве идентификатора таски,
- `go-playground/validator/v10` - для валидации конфига

## Настройка
В изначальной реализации все значения были константами, поэтому решил добавить возможность это конфигурировать.

Конфигурацию решил разделить на тип `TaskProcessingConfig` и набор глобальных переменных.

### Глобальные переменные
Я понимаю, что использование глобальных переменных является антипаттерном, но данные глобальные переменные нужны для настройки "симуляции",
поэтому я решил, что через конфиг такие значения задавать будет не очень красиво *(всё-таки этот код мы рассматриваем как код из продакшена)*.

Всего есть 3 глобальные переменные:
- `IncorrectTaskTimeDivision` - если при делении на это число кол-ва наносекунд текущего времени остаток от деления будет больше 1, 
то таска будет сгенерирована с ошибкой,
- `CreateTaskDuration` - периодичность создания тасок,
- `ProcessTaskDuration` - пауза, имитирующая обработку таски, если таска не содержит ошибки.

### TaskProcessingConfig

Объект конфигурации содержит следующие поля:
- `GeneratingTasksDuration` - время работы воркеров, генерирующих таски,
- `MaxProcessingWorkerDuration` - максимально возможное время работы воркеров, обрабатывающих таски,
- `MaxHandleProcessedDuration` - максимально возможное время работы горутины, выводящий результат на экран,
- `UnprocessedTasksChannelBufferSize` - размер канала для хранения необработанных тасок,
- `ProcessedTasksChannelBufferSize` - размер канала для хранения обработанных тасок,
- `FillingTasksChannelWorkerCount` - количество воркеров, создающих таски,
- `ProcessingTasksChannelWorkerCount` - количество воркеров, обрабатывающих таски,
- `PrintingTasksPeriod` - с какой периодичностью выводить результат обработки тасков в консоль,
- `IsPrintTasksDetailed` - нужно ли выводить помимо статистики подробную информацию о каждой таске,
- `LogLevel` - уровень логирования для `uber-go/zap`

После создания объект конфигурации валидируется при помощи пакета `go-playground/validator/v10`.
Основное назначение - не допустить нулевые значения.

## Многопоточность

Для реализации многопоточности в генерации и обработке задач использовал паттер Worker Pool. 
Для вывода на экран решил отказаться от многопоточности, чтобы информация выводилась в консоль один раз.

Количество воркеров для обоих pool-ов, а также время их максимальной работы можно задать в `TaskProcessingConfig`.

## Изменение формата тасков

Решил сделать полностью новый тип для хранения тасок:
```go
// Task contains information about a one task
type Task struct {
	Uuid       uuid.UUID
	CreateTime time.Time
	FinishTime time.Time
	Result     []byte
	Err        error
}
```

Изменил подход к формированию ошибочных тасок. Решил добавить отдельное поле `Err`, чтобы в нём хранить ошибку (т.к. у нас могут быть разные типы ошибок).

Для идентификации решил использовать тип `uuid.UUID` для большей уникальности и возможности генерации уникальных значений в нескольких горутинах.

## Условие генерации ошибок

В задании условие генерации ошибок было `time.Now().Nanosecond()%2 > 0`, 
но на моём компьютере кол-во наносекунд всегда было кратно 100, т.е. оканчивалось на 00.

Поэтому, чтобы появлялись таски с ошибкой, я добавил глобальную переменную `IncorrectTaskTimeDivision` для настройки. 
Значением по умолчанию является 2, чтобы выполнить условия задачи.

## Генерация и обработка тасков

Вынес генерацию, обработку и вывод статистики в 3 функции:
- `FillTaskChannel` - заполняет переданный канал тасками,
- `ProcessTaskChannel` - обрабатывает таски из одного переданного канала и записывает обработанные в другой,
- `HandleProcessedTasksChannel` - раз в заданный промежуток времени выводит на экран кол-во успешно и неуспешно обработанных тасок 
    и, если нужно, выводит на экран все обработанные таски.

Предполагается, что функции `FillTaskChannel` и `ProcessTaskChannel` будут работать в многопоточном режиме, 
а вот `HandleProcessedTasksChannel` хоть и может так работать, 
но тогда результат будет выводиться несколько раз и таски не будут хоть как-нибудь отсортированы.

## Логирование

Чтобы была возможность проще отлаживать код, а также на будущее добавить сохранения логов в файл, решил использовать для логирования пакет `uber-go/zap`.

В текущей логике логирования есть один нюанс - при обработке таски с ошибкой, информация об этом выводится в `Debug` лог потому, что может генерироваться очень много ошибок и видеть полотно логов
будет не очень приятно. Само собой в продакшене мы бы писали это в уровень `Error`.